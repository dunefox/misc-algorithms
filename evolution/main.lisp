(defparameter *ops* '(+ - * ))
(defparameter *max-depth* 5)
(defparameter *max-nodes* 5)
(defparameter *max-range* 5)
(defparameter *numbers* (loop :for n :below *max-range* :collect (+ 1 n)))
(defparameter *elts* (append *ops* *numbers*))

(defun make-tree (symbol depth)
  (cond ((<= depth 0) (elt *numbers* (random *max-range*)))
        ((not (member symbol *ops*)) symbol)
        (t (let* ((slots (+ 2 (random *max-nodes*)))
                  (tree-level (loop :repeat slots :collect (elt *elts* (random (length *elts*))))))
             (cons symbol (mapcar (lambda (x) (make-tree x (- depth 1))) tree-level))))))

(defun calc-depth (tree)
  (progn
    (defun go_ (form &optional (depth 1))
      (let ((cleaned (remove-if-not #'listp form)))
        (cond ((eq cleaned '()) depth)
              (t (mapcar (lambda (x) (go_ x (1+ depth))) cleaned)))))
                                        ;(setf depths '())
    (reduce #'max (flatten (go_ tree)))))

(defun flatten (l)
  (cond ((null l) nil)
        ((atom l) (list l))
        (t (loop for a in l appending (flatten a)))))
